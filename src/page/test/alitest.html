<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html class="gblog">
<head>
    <title>阿里测试demo</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="import" href="../weight/cssjslink.html?__inline">
</head>
<body>
<link rel="import" href="../weight/header.html?__inline">
<link rel="stylesheet" href="alitest.css">
<div class="banner">
    <!--<link rel="import" href="../weight/b-inner.html?__inline">-->
</div>
<div class="main">
    <a href="alitest.js" target="_blank">查看源代码</a>
    <a href="alitest.css" target="_blank">查看css 源码</a>
    <div class="zwrap">
        <div class="title">
            第一题，链表
        </div>
        <div class="content">
           <pre><code>
function Node(data) {
    this.data = data;
    this.next = null;
}

Node.prototype.getNext = function () {
    return this.next;
}

function ListNode() {
    this.head = null;
    this.foot = null;
}

ListNode.prototype.addFirst = function (node) {

    node.next = this.head;
    this.head = node;
    if (this.foot == null) {
        this.foot = this.head
    }

}
ListNode.prototype.addLast = function (node) {
    if (this.foot == null) {
        this.foot = node;
    }
    else {
        this.foot.next = node;
        this.foot = node;
    }
    if (this.head == null) {
        this.head = this.foot
    }
}
ListNode.prototype.getHead = function () {
    return this.head;
}
function test() {
    console.log("=====第一题合并两个有序链表============")
    var list1 = new ListNode();
    var list2 = new ListNode();
    var array1 = [2, 3, 5, 6, 9, 18];
    var array2 = [3, 4, 7, 9, 10, 12];
    // 构造链表
    for (var i = 0; i < array1.length; i++) {
        var node = new Node(array1[i]);
        list1.addLast(node)
    }
    for (var j = 0; j < array2.length; j++) {
        var node = new Node(array2[j]);
        list2.addLast(node)
    }

    // 面试第一题，合并两个有序链表
    var head1 = list1.getHead();
    var head2 = list2.getHead();
    var list3 = new ListNode();
    while (head1 || head2) {
        var d1 = head1 ? head1.data : null;
        var d2 = head2 ? head2.data : null;
        if (d1 && d2) {
            if (d1 > d2) {
                list3.addLast(new Node(d2));
                head2 = head2.getNext();
            } else {
                list3.addLast(new Node(d1));
                head1 = head1.getNext();
            }
        } else if (d1) {
            list3.addLast(new Node(d1));
            head1 = head1.getNext();
        } else {
            list3.addLast(new Node(d2));
            head2 = head2.getNext();
        }
    }
    var head3 = list3.getHead();
    while (head3) {
        console.log(head3.data);
        head3 = head3.getNext();
    }
    console.log("===============华丽的分割线 倒叙输出链表==============")
    var head4 = list3.getHead();
    var array4 = [];// 理解为一个栈操作，这儿不写栈的实现了，遍历入栈，倒叙输出则是弹栈
    while (head4) {
        array4.push(head4.data)// 入栈操作
        head4 = head4.getNext();
    }
    var m = array4.pop();
    while (m) {
        console.log(m);// 出栈
        m = array4.pop();
    }
}

test();
           </code></pre>
        </div>
    </div>
    <div class="zwrap">
        <div class="title">object 实现clone</div>
        <div class="content">
            <pre><code>
function clonetest() {
    Object.prototype.clone = function () {
        var temp = Object.create(this);
        for (var key in this) {
            if (typeof this[key] == "object") {
                if (this[key] instanceof Array) {
                    temp[key] = [];
                    for (var i in this[key]) {
                        if (typeof this[key][i] != "function") {
                            temp[key].push(this[key][i])
                        }
                    }
                }
                else {
                    temp[key] = this[key].clone();
                }

            } else {
                temp[key] = this[key];
            }
        }
        return temp;
    }
    console.log("===============第二题 object clone==============")
    var a = {a: 1, b: [1, 2, 3], c: {d: "", e: [{ss: "sdf"}]}};
    var b = a.clone();
    console.log(a === b);
    console.log(JSON.stringify(a) == JSON.stringify(b));
    console.log(JSON.stringify(a));
    console.log(JSON.stringify(b));

}
clonetest();
            </code></pre>
        </div>
    </div>
    <div class="zwrap">
        <div class="title">
            第三题 快排
        </div>
        <div class="content">
            <pre><code>
var qsort = function (array) {
    if (array.length <= 1) {
        return array;
    }
    var pivotIndex = Math.floor(array.length / 2);//取半
    var pivot = array.splice(pivotIndex, 1)[0];
    var tmpleft = [];
    var tmpright = [];
    for (var i = 0; i < array.length; i++) {
        if (array[i] < pivot) {
            tmpleft.push(array[i]);
        } else {
            tmpright.push(array[i]);
        }
    }
    return qsort(tmpleft).concat([pivot], qsort(tmpright));
};
console.log("=================第三题 快排===================")
console.log(qsort([3, 7, 4, 9, -1, 20]));
            </code></pre>
        </div>
    </div>
    <div class="zwrap">
        <div class="title">

        </div>
        <div class="content">
            <pre><code>
// 继承
// 继承工具类，章鱼工具tool函数底层实现，此方法无法继承 构造器方法。所以要实现构造器，需要在子类中写额外代码。
function ext(subClass, superClass) {
    function o() {
        this.constructor = subClass;
    }

    o.prototype = superClass.prototype;
    return (subClass.prototype = new o())
}

function Parent(a) {
    this.a = a;
}

function Child() {
    Parent.call(this);// 重定向 new 出来的prototype 指针问题。第二个作用是，super 父类构造器方法（）
}

ext(Child, Parent);// 实现继承prototype 属性。（工具类中还没想好怎么实现 ，Parent.call(this) 这种，所以工具类不太完美，Parent.call(this) 这种写法像补丁）
var m = new Child();
console.log("==================继承==============")
console.log(m instanceof Parent);
console.log(m instanceof Child)
            </code></pre>
        </div>
    </div>
    <div class="zwrap">
        <div class="title">
            闭包计数
        </div>
        <div class="content">
            <pre><code>
                console.log("==================第6题闭包计数器==============")
var count = (function () {
    var c = 0;
    return function () {
        return c += 1;
    }
})();
console.log(count())
console.log(count())
console.log(count())
console.log(count())
console.log(count())
            </code></pre>
        </div>
    </div>
    <div class="zwrap">
        <div class="title">css loading</div>
        <div class="content">
            <div id="loading">
                <div id="rond">
                    <div id="dot"></div>
                </div>
            </div>
            <pre><code>
            &lt;div id="loading">
                &lt;div id="rond">
                    &lt;div id="dot">&lt;/div>
                &lt;/div>
            &lt;/div>
                
#loading {
  background-color : #C2C2C2;
  height : 140px;
  width : 150px;
  padding-top : 10px;
  float : left;
  position : relative;
}

#casePourpre #load {
  color : #886ed7;
  font-family : calibri;
  text-align : center;
  position : absolute;
  top : 42px;
  left :42px;
}

#dot {
  height : 10px;
  width : 10px;
  position : absolute;
  background-color : #fff;
  border-radius : 50%;
  top : 5px;
  left : 10px;
}

#rond {
  height  : 100px;
  width : 100px;
  border : 1px solid #fff;
  border-radius : 50%;
  position :absolute;
  top : 20px;
  left : 15px;
  -webkit-animation : rond 2s infinite;
}

@-webkit-keyframes rond {
  0% {-webkit-transform : rotate(0deg);}
  100% {-webkit-transform : rotate(360deg);}
}
            </code></pre>
        </div>
    </div>
    <div class="zwrap">
        <div class="title">骰子布局</div>
        <div class="content">

        </div>
    </div>
    <div class="zwrap">
        <div class="title">

        </div>
        <div class="content">
            <div class="touzi">
                <div class="touzi-item"></div>
                <div class="touzi-item"></div>
                <div class="touzi-item"></div>
            </div>
            <pre><code>
            &lt;div class="touzi">
                &lt;div class="touzi-item">&lt;/div>
                &lt;div class="touzi-item">&lt;/div>
                &lt;div class="touzi-item">&lt;/div>
            &lt;/div>
  // 骰子布局
.touzi {
  display: flex;
  background-color: #ccc;
  width: 90px;
  height: 90px;
}

.touzi-item {
  display: block;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background-color: #333;
  margin: 0px !important; // 博客中样式覆盖，此行并不是必须的
}

.touzi-item:nth-child(2) {
  align-self: center;
}

.touzi-item:nth-child(3) {
  align-self: flex-end;
}
            </code></pre>
        </div>

    </div>
</div>
<script src="alitest.js">

</script>
</body>
</html>
